#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <arpa/inet.h>
#include <netinet/ip_icmp.h>
#include <sys/socket.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>

#define PACKET_SIZE 64
#define ICMP_ECHO_REQUEST 8
#define NUM_THREADS 10

struct PingData {
    const char *target_ip;
    int pings_per_second;
};

struct PingStats {
    pthread_mutex_t mutex;
    int sent_pings;
    int successful_pings;
};

// Global variable to allow signal handling
struct PingStats pingStats;

void signalHandler(int signal) {
    // Display final stats and terminate program
    printf("\nTotal pings sent: %d\n", pingStats.sent_pings);
    printf("Successful pings: %d\n", pingStats.successful_pings);

    // Cleanup and exit
    pthread_mutex_destroy(&pingStats.mutex);
    exit(EXIT_SUCCESS);
}

unsigned short checksum(void *b, int len) {
    unsigned short *buf = b;
    unsigned int sum = 0;
    unsigned short result;

    for (sum = 0; len > 1; len -= 2)
        sum += *buf++;

    if (len == 1)
        sum += *(unsigned char *)buf;

    sum = (sum >> 16) + (sum & 0xFFFF);
    sum += (sum >> 16);
    result = ~sum;

    return result;
}

void *sendPingRequest(void *arg) {
    struct PingData *pingData = (struct PingData *)arg;

    int sockfd;
    struct sockaddr_in dest_addr;
    struct icmphdr icmp_hdr;
    char packet[PACKET_SIZE];
    int send_bytes;
    struct timespec sleep_time;

    // Create socket
    sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sockfd == -1) {
        perror("socket");
        exit(EXIT_FAILURE);
    }

    // Set destination address
    memset(&dest_addr, 0, sizeof(dest_addr));
    dest_addr.sin_family = AF_INET;
    if (inet_pton(AF_INET, pingData->target_ip, &dest_addr.sin_addr) != 1) {
        perror("inet_pton");
        close(sockfd);
        exit(EXIT_FAILURE);
    }

    // Initialize ICMP header
    memset(&icmp_hdr, 0, sizeof(icmp_hdr));
    icmp_hdr.type = ICMP_ECHO_REQUEST;
    icmp_hdr.code = 0;
    icmp_hdr.checksum = 0;
    icmp_hdr.un.echo.id = getpid();
    icmp_hdr.un.echo.sequence = 0;
    icmp_hdr.checksum = checksum(&icmp_hdr, sizeof(icmp_hdr));

    // Construct packet
    memcpy(packet, &icmp_hdr, sizeof(icmp_hdr));

    // Calculate sleep time between pings
    sleep_time.tv_sec = 0;
    sleep_time.tv_nsec = 1000000000 / pingData->pings_per_second; // 1 second divided by pings per second

    // Send ICMP echo requests
    while (1) {
        send_bytes = sendto(sockfd, packet, sizeof(packet), 0, (struct sockaddr *)&dest_addr, sizeof(dest_addr));
        if (send_bytes == -1) {
            perror("sendto");
            close(sockfd);
            exit(EXIT_FAILURE);
        }

        // Update sent pings count
        pthread_mutex_lock(&pingStats.mutex);
        pingStats.sent_pings++;
        pthread_mutex_unlock(&pingStats.mutex);

        // Sleep for the calculated time
        nanosleep(&sleep_time, NULL);
    }
}

void *pingStatsListener(void *arg) {
    // Set up signal handling to display stats on interruption
    signal(SIGINT, signalHandler);

    // Display stats every second
    while (1) {
        // Display stats
        pthread_mutex_lock(&pingStats.mutex);
        printf("\rSent pings: %d, Successful pings: %d", pingStats.sent_pings, pingStats.successful_pings);
        fflush(stdout);
        pthread_mutex_unlock(&pingStats.mutex);

        // Sleep for 1 second
        sleep(1);
    }
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <target_ip> <pings_per_second>\n", argv[0]);
        return EXIT_FAILURE;
    }

    const char *target_ip = argv[1];
    int pings_per_second = atoi(argv[2]);

    if (pings_per_second <= 0) {
        fprintf(stderr, "Pings per second should be greater than 0.\n");
        return EXIT_FAILURE;
    }

    // Initialize global stats
    pingStats.sent_pings = 0;
    pingStats.successful_pings = 0;
    pthread_mutex_init(&pingStats.mutex, NULL);

    // Create threads
    pthread_t sendThread, statsThread;
    struct PingData pingData = {target_ip, pings_per_second};

    // Create thread for sending pings
    if (pthread_create(&sendThread, NULL, sendPingRequest, (void *)&pingData) != 0) {
        perror("pthread_create");
        return EXIT_FAILURE;
    }

    // Create thread for displaying stats
    if (pthread_create(&statsThread, NULL, pingStatsListener, NULL) != 0) {
        perror("pthread_create");
        return EXIT_FAILURE;
    }

    // Wait for send thread to finish (this part can be adjusted based on your requirements)
    pthread_join(sendThread, NULL);

    // Cleanup and exit
    pthread_mutex_destroy(&pingStats.mutex);
    return EXIT_SUCCESS;
}
